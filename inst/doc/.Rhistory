getBoundingBox <- function(P0, P1) {#
    llx <- min(P0[1], P1[1])#
    lly <- min(P0[2], P1[2])#
    urx <- max(P0[1], P1[1])#
    ury <- max(P0[2], P1[2])#
#
    bb <- c(llx, lly, urx, ury)#
    }#
#
doBoxesIntersect <- function(box1, box2) {#
    ans <- FALSE#
    chk1 <- box1[1] <= box2[3]#
    chk2 <- box1[3] >= box2[1]#
    chk3 <- box1[2] <= box2[4]#
    chk4 <- box1[4] >= box2[2]#
    if (chk1 && chk2 && chk3 && chk4) ans <- TRUE#
    ans#
    }#
#
isPointOnLine <- function(segment, point) {#
	newseg <- c(0.0, 0.0, segment[3] - segment[1], segment[4] - segment[2])#
	newpt <- c(point[1] - segment[1], point[2] - segment[2])#
	ans <- newseg[3]*newpt[2] - newpt[1]*newseg[4]#
	return(isTRUE(all.equal(abs(ans), 0)))#
	}#
#
isPointRightOfLine <- function(segment, point) {#
	newseg <- c(0.0, 0.0, segment[3] - segment[1], segment[4] - segment[2])#
	newpt <- c(point[1] - segment[1], point[2] - segment[2])#
	ans <- newseg[3]*newpt[2] - newpt[1]*newseg[4]#
	return(ans < 0)#
	}#
#
lineSegmentTouchesOrCrossesLine <- function(segment1, segment2) {#
	ans <- 	(xor((isPointOnLine(segment1, segment2[1:2]) ||#
			isPointOnLine(segment1, segment2[3:4]) ||#
			isPointRightOfLine(segment1, segment2[1:2])),#
			isPointRightOfLine(segment1, segment2[3:4])))#
	return(ans)#
	}#
#
doSegmentsIntersect <- function(segment1, segment2) {#
	box1 <- getBoundingBox(segment1[1:2], segment1[3:4])#
	box2 <- getBoundingBox(segment2[1:2], segment2[3:4])#
	return(doBoundingBoxesIntersect(box1, box2) &&#
		lineSegmentTouchesOrCrossesLine(segment1, segment2) &&#
		lineSegmentTouchesOrCrossesLine(segment2, segment1))#
	}
intersectTest <- function() {#
	x <- runif(4, -5, 5)#
	y <- runif(4, -5, 5)#
	xy <- data.frame(x = x, y = y) #
	plot(-10:10, -10:10, type = "n")#
	points(xy, cex = 0.5)#
	text(xy[seq(1, nrow(xy), by = 2),], labels = 1:(nrow(xy)/2), pos = 4, cex = 0.75)#
	s <- seq(1, nrow(xy), by = 2)#
	for (n in s) {#
	    segments(xy[n,1], xy[n,2], xy[n+1,1], xy[n+1,2], col = "red")#
	    polygon(x = c(xy[n,1], xy[n,1], xy[n+1,1], xy[n+1,1]),#
	        y = c(xy[n,2], xy[n+1,2], xy[n+1,2], xy[n,2]))#
	    }#
	for(n in 1:(length(s)-1)) {#
		cross <- doBoxesIntersect(#
	        getBoundingBox(P0 = c(xy[n,1], xy[n,2]), P1 = c(xy[n+1,1], xy[n+1,2])),#
	        getBoundingBox(P0 = c(xy[n+2,1], xy[n+2,2]), P1 = c(xy[n+3,1], xy[n+3,2])))#
		cat("Bounding box", n, "intersects bounding box", n+1, ":", cross, "\n")#
		inter <- doSegmentsIntersect(#
	        segment1 = c(xy[n,1], xy[n,2], xy[n+1,1], xy[n+1,2]),#
	        segment2 = c(xy[n+2,1], xy[n+2,2], xy[n+3,1], xy[n+3,2]))#
	    cat("Segment", n, "intersects segment", n+1, ":", inter, "\n")#
		}#
	}
doSegmentsIntersect <- function(segment1, segment2) {#
	box1 <- getBoundingBox(segment1[1:2], segment1[3:4])#
	box2 <- getBoundingBox(segment2[1:2], segment2[3:4])#
	return(doBoxesIntersect(box1, box2) &&#
		lineSegmentTouchesOrCrossesLine(segment1, segment2) &&#
		lineSegmentTouchesOrCrossesLine(segment2, segment1))#
	}
intersectTest()
selectCIExy <- function(L1 = NULL, L2 = NULL) {#
#
	if (is.null(L1)) stop("You must give a wavelength")#
	data(CIExyz) #
	xy <- CIExyz[,c(2,3)] #
	xy <- rbind(xy, xy[1,]) #
	ans <- grep(L1, CIExyz$wavelength)#
	ans <-ans[1] #
	xy[ans,]#
	p0x <- xy[ans,1]#
	p0y <- xy[ans,2]#
	D65 <- getWhiteValues("D65") #
	Dx <- D65[1,1]#
	Dy <- D65[1,2]#
	m0 <- (Dy - p0y) / (Dx - p0x) #
	b0 <- (-m0 * p0x) + p0y #
	x1 <- p0x#
	y1 <- p0y#
	x2 <- Dx#
	y2 <- Dy#
	its <- nrow(xy)-1#
	for (n in 1:its) {#
		den <- (x1 - x2) * (xy[n,2] - xy[n+1,2]) - (y1 - y2) * (xy[n,1] - xy[n+1,1])#
		if (den == 0) {#
			next#
			}#
		num1 <- (x1 * y2 - y1 * x2) * (xy[n,1] - xy[n+1,1])#
		num2 <- (x1 - x2) * (xy[n,1] * xy[n+1,2] - xy[n,2] * xy[n+1,1])#
		num3 <- (x1 * y2 - y1 * x2) * (xy[n,2] - xy[n+1,2])#
		num4 <- (y1 - y2) * (xy[n,1] * xy[n+1,2] - xy[n,2] * xy[n+1,1]) #
		Px = (num1 - num2)/den#
		Py = (num3 - num4)/den#
		}#
	for (n in 1:its) {#
		inter <- doSegmentsIntersect(#
	        segment1 = c(p0x, p0y, Dx, Dy),#
	        segment2 = c(xy[n,1], xy[n,2], xy[n+1,1], xy[n+1,2]))#
	    if (inter) cat("Segment", n, "intersects segment", n+1, "\n")#
		}#
	}
selectCIExy <- function(L1 = NULL, L2 = NULL) {#
#
	if (is.null(L1)) stop("You must give a wavelength")#
	data(CIExyz) #
	xy <- CIExyz[,c(2,3)] #
	xy <- rbind(xy, xy[1,]) #
	ans <- grep(L1, CIExyz$wavelength)#
	ans <-ans[1] #
	xy[ans,]#
	p0x <- xy[ans,1]#
	p0y <- xy[ans,2]#
	D65 <- getWhiteValues("D65") #
	Dx <- D65[1,1]#
	Dy <- D65[1,2]#
	m0 <- (Dy - p0y) / (Dx - p0x) #
	b0 <- (-m0 * p0x) + p0y #
	x1 <- p0x#
	y1 <- p0y#
	x2 <- Dx#
	y2 <- Dy#
	its <- nrow(xy)-1#
	for (n in 1:its) {#
		den <- (x1 - x2) * (xy[n,2] - xy[n+1,2]) - (y1 - y2) * (xy[n,1] - xy[n+1,1])#
		if (den == 0) {#
			next#
			}#
		num1 <- (x1 * y2 - y1 * x2) * (xy[n,1] - xy[n+1,1])#
		num2 <- (x1 - x2) * (xy[n,1] * xy[n+1,2] - xy[n,2] * xy[n+1,1])#
		num3 <- (x1 * y2 - y1 * x2) * (xy[n,2] - xy[n+1,2])#
		num4 <- (y1 - y2) * (xy[n,1] * xy[n+1,2] - xy[n,2] * xy[n+1,1]) #
		Px = (num1 - num2)/den#
		Py = (num3 - num4)/den#
		}#
	for (n in 1:its) {#
	   	cross <- doBoxesIntersect(#
	        getBoundingBox(P0 = c(p0x, p0y), P1 = c(Dx, Dy)),#
	        getBoundingBox(P0 = c(xy[n,1], xy[n,2]), P1 = c(xy[n+1,1], xy[n+1,2])))#
		if (cross) cat("Bounding box", n, "intersects p0 D65 bb\n")#
#
		inter <- doSegmentsIntersect(#
	        segment1 = c(p0x, p0y, Dx, Dy),#
	        segment2 = c(xy[n,1], xy[n,2], xy[n+1,1], xy[n+1,2]))#
	    if (inter) cat("Segment", n, "intersects segment", n+1, "\n")#
		}#
	}
selectCIExy(L1 = 600)
selectCIExy <- function(L1 = NULL, L2 = NULL) {#
#
	if (is.null(L1)) stop("You must give a wavelength")#
	data(CIExyz) #
	xy <- CIExyz[,c(2,3)] #
	xy <- rbind(xy, xy[1,]) #
	ans <- grep(L1, CIExyz$wavelength)#
	ans <-ans[1] #
	xy[ans,]#
	p0x <- xy[ans,1]#
	p0y <- xy[ans,2]#
	D65 <- getWhiteValues("D65") #
	Dx <- D65[1,1]#
	Dy <- D65[1,2]#
	m0 <- (Dy - p0y) / (Dx - p0x) #
	b0 <- (-m0 * p0x) + p0y #
	x1 <- p0x - 0.1#
	y1 <- p0y - 0.1#
	x2 <- Dx#
	y2 <- Dy#
	its <- nrow(xy)-1#
	for (n in 1:its) {#
		den <- (x1 - x2) * (xy[n,2] - xy[n+1,2]) - (y1 - y2) * (xy[n,1] - xy[n+1,1])#
		if (den == 0) {#
			next#
			}#
		num1 <- (x1 * y2 - y1 * x2) * (xy[n,1] - xy[n+1,1])#
		num2 <- (x1 - x2) * (xy[n,1] * xy[n+1,2] - xy[n,2] * xy[n+1,1])#
		num3 <- (x1 * y2 - y1 * x2) * (xy[n,2] - xy[n+1,2])#
		num4 <- (y1 - y2) * (xy[n,1] * xy[n+1,2] - xy[n,2] * xy[n+1,1]) #
		Px = (num1 - num2)/den#
		Py = (num3 - num4)/den#
		}#
	for (n in 1:its) {#
	   	cross <- doBoxesIntersect(#
	        getBoundingBox(P0 = c(p0x, p0y), P1 = c(Dx, Dy)),#
	        getBoundingBox(P0 = c(xy[n,1], xy[n,2]), P1 = c(xy[n+1,1], xy[n+1,2])))#
		if (cross) cat("Bounding box", n, "intersects p0 D65 bb\n")#
#
		inter <- doSegmentsIntersect(#
	        segment1 = c(p0x, p0y, Dx, Dy),#
	        segment2 = c(xy[n,1], xy[n,2], xy[n+1,1], xy[n+1,2]))#
	    if (inter) cat("p0 D65 intersects segment", n, "\n")#
		}#
	}
selectCIExy(L1 = 650)
selectCIExy(L1 = 550)
selectCIExy <- function(L1 = NULL, L2 = NULL) {#
#
	if (is.null(L1)) stop("You must give a wavelength")#
	data(CIExyz) #
	xy <- CIExyz[,c(2,3)] #
	xy <- rbind(xy, xy[1,]) #
	ans <- grep(L1, CIExyz$wavelength)#
	ans <-ans[1] #
	xy[ans,]#
	p0x <- xy[ans,1]#
	p0y <- xy[ans,2]#
	D65 <- getWhiteValues("D65") #
	Dx <- D65[1,1]#
	Dy <- D65[1,2]#
	m0 <- (Dy - p0y) / (Dx - p0x) #
	b0 <- (-m0 * p0x) + p0y #
	x1 <- p0x#
	y1 <- p0y#
	x2 <- Dx#
	y2 <- Dy#
	its <- nrow(xy)-1#
	for (n in 1:its) {#
		den <- (x1 - x2) * (xy[n,2] - xy[n+1,2]) - (y1 - y2) * (xy[n,1] - xy[n+1,1])#
		if (den == 0) {#
			next#
			}#
		num1 <- (x1 * y2 - y1 * x2) * (xy[n,1] - xy[n+1,1])#
		num2 <- (x1 - x2) * (xy[n,1] * xy[n+1,2] - xy[n,2] * xy[n+1,1])#
		num3 <- (x1 * y2 - y1 * x2) * (xy[n,2] - xy[n+1,2])#
		num4 <- (y1 - y2) * (xy[n,1] * xy[n+1,2] - xy[n,2] * xy[n+1,1]) #
		Px = (num1 - num2)/den#
		Py = (num3 - num4)/den#
		}#
	for (n in 1:its) {#
	   	cross <- doBoxesIntersect(#
	        getBoundingBox(P0 = c(p0x, p0y), P1 = c(Dx, Dy)),#
	        getBoundingBox(P0 = c(xy[n,1], xy[n,2]), P1 = c(xy[n+1,1], xy[n+1,2])))#
		if (cross) cat("Bounding box", n, "intersects p0 D65 bb\n")#
#
		inter <- doSegmentsIntersect(#
	        segment1 = c(p0x, p0y, Dx, Dy),#
	        segment2 = c(xy[n,1], xy[n,2], xy[n+1,1], xy[n+1,2]))#
	    if (inter) cat("p0 D65 intersects segment", n, "\n")#
		}#
	}
selectCIExy(L1 = 490)
selectCIExy(L1 = 480)
selectCIExy(L1 = 500)
selectCIExy(L1 = 520)
selectCIExy(L1 = 540)
selectCIExy(L1 = 560)
selectCIExy(L1 = 580)
selectCIExy(L1 = 400)
ls()
library("knitr")
knit("photoSpec.Rnw")
library("photoSpec")
selectCIExy <- function(L1 = NULL, L2 = NULL) {#
	getBoundingBox <- function(P0, P1) {#
	    llx <- min(P0[1], P1[1])#
	    lly <- min(P0[2], P1[2])#
	    urx <- max(P0[1], P1[1])#
	    ury <- max(P0[2], P1[2])#
	    bb <- c(llx, lly, urx, ury)#
	    }#
	doBoxesIntersect <- function(box1, box2) {#
	    ans <- FALSE#
	    chk1 <- box1[1] <= box2[3]#
	    chk2 <- box1[3] >= box2[1]#
	    chk3 <- box1[2] <= box2[4]#
	    chk4 <- box1[4] >= box2[2]#
	    if (chk1 && chk2 && chk3 && chk4) ans <- TRUE#
	    ans#
	    }#
	isPointOnLine <- function(segment, point) {#
		newseg <- c(0.0, 0.0, segment[3] - segment[1], segment[4] - segment[2])#
		newpt <- c(point[1] - segment[1], point[2] - segment[2])#
		ans <- newseg[3]*newpt[2] - newpt[1]*newseg[4]#
		return(isTRUE(all.equal(abs(ans), 0)))#
		}#
	isPointRightOfLine <- function(segment, point) {#
		newseg <- c(0.0, 0.0, segment[3] - segment[1], segment[4] - segment[2])#
		newpt <- c(point[1] - segment[1], point[2] - segment[2])#
		ans <- newseg[3]*newpt[2] - newpt[1]*newseg[4]#
		return(ans < 0)#
		}#
	lineSegmentTouchesOrCrossesLine <- function(segment1, segment2) {#
		ans <- 	(isPointOnLine(segment1, segment2[1:2]) ||#
				isPointOnLine(segment1, segment2[3:4]) ||#
				xor(isPointRightOfLine(segment1, segment2[1:2]),#
				isPointRightOfLine(segment1, segment2[3:4])))#
		return(ans)#
		}#
	doSegmentsIntersect <- function(segment1, segment2) {#
		box1 <- getBoundingBox(segment1[1:2], segment1[3:4])#
		box2 <- getBoundingBox(segment2[1:2], segment2[3:4])#
		return(doBoxesIntersect(box1, box2) &&#
			lineSegmentTouchesOrCrossesLine(segment1, segment2) &&#
			lineSegmentTouchesOrCrossesLine(segment2, segment1))#
		}#
	if (is.null(L1)) stop("You must give a wavelength")#
	data(CIExyz) #
	xy <- CIExyz[,c(2,3)] #
	xy <- rbind(xy, xy[1,]) #
	ans <- grep(L1, CIExyz$wavelength)#
	ans <-ans[1] #
	xy[ans,]#
	p0x <- xy[ans,1]#
	p0y <- xy[ans,2]#
	D65 <- getWhiteValues("D65") #
	Dx <- D65[1,1]#
	Dy <- D65[1,2]#
	m0 <- (Dy - p0y) / (Dx - p0x) #
	b0 <- (-m0 * p0x) + p0y #
	x1 <- p0x#
	y1 <- p0y#
	x2 <- Dx#
	y2 <- Dy#
	its <- nrow(xy)-1#
	for (n in 1:its) {#
		den <- (x1 - x2) * (xy[n,2] - xy[n+1,2]) - (y1 - y2) * (xy[n,1] - xy[n+1,1])#
		if (den == 0) {#
			next#
			}#
		num1 <- (x1 * y2 - y1 * x2) * (xy[n,1] - xy[n+1,1])#
		num2 <- (x1 - x2) * (xy[n,1] * xy[n+1,2] - xy[n,2] * xy[n+1,1])#
		num3 <- (x1 * y2 - y1 * x2) * (xy[n,2] - xy[n+1,2])#
		num4 <- (y1 - y2) * (xy[n,1] * xy[n+1,2] - xy[n,2] * xy[n+1,1]) #
		Px = (num1 - num2)/den#
		Py = (num3 - num4)/den#
		}#
	keep <- c()#
	for (n in 1:its) {#
	   	cross <- doBoxesIntersect(#
	        getBoundingBox(P0 = c(p0x, p0y), P1 = c(Dx, Dy)),#
	        getBoundingBox(P0 = c(xy[n,1], xy[n,2]), P1 = c(xy[n+1,1], xy[n+1,2])))#
		if (cross) cat("Bounding box", n, "intersects p0 D65 bb\n")#
#
		inter <- doSegmentsIntersect(#
	        segment1 = c(p0x, p0y, Dx, Dy),#
	        segment2 = c(xy[n,1], xy[n,2], xy[n+1,1], xy[n+1,2]))#
	    if (inter) {#
	    	cat("p0 D65 intersects segment", n, "\n")#
	    	keep <- c(keep, n)#
	    	}#
		}#
 	return(CIExyz[keep,])#
	}
tmp <- selectCIExy(L1 = 500)
tmp
tmp <- selectCIExy(L1 = 450); tmp
tmp <- selectCIExy(L1 = 600); tmp
tmp <- selectCIExy(L1 = 650); tmp
selectCIExy <- function(L1 = NULL, L2 = NULL) {#
	getBoundingBox <- function(P0, P1) {#
	    llx <- min(P0[1], P1[1])#
	    lly <- min(P0[2], P1[2])#
	    urx <- max(P0[1], P1[1])#
	    ury <- max(P0[2], P1[2])#
	    bb <- c(llx, lly, urx, ury)#
	    }#
	doBoxesIntersect <- function(box1, box2) {#
	    ans <- FALSE#
	    chk1 <- box1[1] <= box2[3]#
	    chk2 <- box1[3] >= box2[1]#
	    chk3 <- box1[2] <= box2[4]#
	    chk4 <- box1[4] >= box2[2]#
	    if (chk1 && chk2 && chk3 && chk4) ans <- TRUE#
	    ans#
	    }#
	isPointOnLine <- function(segment, point) {#
		newseg <- c(0.0, 0.0, segment[3] - segment[1], segment[4] - segment[2])#
		newpt <- c(point[1] - segment[1], point[2] - segment[2])#
		ans <- newseg[3]*newpt[2] - newpt[1]*newseg[4]#
		return(isTRUE(all.equal(abs(ans), 0)))#
		}#
	isPointRightOfLine <- function(segment, point) {#
		newseg <- c(0.0, 0.0, segment[3] - segment[1], segment[4] - segment[2])#
		newpt <- c(point[1] - segment[1], point[2] - segment[2])#
		ans <- newseg[3]*newpt[2] - newpt[1]*newseg[4]#
		return(ans < 0)#
		}#
	lineSegmentTouchesOrCrossesLine <- function(segment1, segment2) {#
		ans <- 	(isPointOnLine(segment1, segment2[1:2]) ||#
				isPointOnLine(segment1, segment2[3:4]) ||#
				xor(isPointRightOfLine(segment1, segment2[1:2]),#
				isPointRightOfLine(segment1, segment2[3:4])))#
		return(ans)#
		}#
	doSegmentsIntersect <- function(segment1, segment2) {#
		box1 <- getBoundingBox(segment1[1:2], segment1[3:4])#
		box2 <- getBoundingBox(segment2[1:2], segment2[3:4])#
		return(doBoxesIntersect(box1, box2) &&#
			lineSegmentTouchesOrCrossesLine(segment1, segment2) &&#
			lineSegmentTouchesOrCrossesLine(segment2, segment1))#
		}#
	if (is.null(L1)) stop("You must give a wavelength")#
	data(CIExyz) #
	xy <- CIExyz[,c(2,3)] #
	xy <- rbind(xy, xy[1,]) #
	ans <- grep(L1, CIExyz$wavelength)#
	ans <-ans[1] #
	xy[ans,]#
	p0x <- xy[ans,1]#
	p0y <- xy[ans,2]#
	D65 <- getWhiteValues("D65") #
	Dx <- D65[1,1]#
	Dy <- D65[1,2]#
	m0 <- (Dy - p0y) / (Dx - p0x) #
	b0 <- (-m0 * p0x) + p0y #
	x1 <- p0x#
	y1 <- p0y#
	x2 <- Dx#
	y2 <- Dy#
	its <- nrow(xy)-1#
	for (n in 1:its) {#
		den <- (x1 - x2) * (xy[n,2] - xy[n+1,2]) - (y1 - y2) * (xy[n,1] - xy[n+1,1])#
		if (den == 0) {#
			next#
			}#
		num1 <- (x1 * y2 - y1 * x2) * (xy[n,1] - xy[n+1,1])#
		num2 <- (x1 - x2) * (xy[n,1] * xy[n+1,2] - xy[n,2] * xy[n+1,1])#
		num3 <- (x1 * y2 - y1 * x2) * (xy[n,2] - xy[n+1,2])#
		num4 <- (y1 - y2) * (xy[n,1] * xy[n+1,2] - xy[n,2] * xy[n+1,1]) #
		Px = (num1 - num2)/den#
		Py = (num3 - num4)/den#
		}#
	keep <- c()#
	for (n in 1:its) {#
	   	cross <- doBoxesIntersect(#
	        getBoundingBox(P0 = c(p0x, p0y), P1 = c(Dx, Dy)),#
	        getBoundingBox(P0 = c(xy[n,1], xy[n,2]), P1 = c(xy[n+1,1], xy[n+1,2])))#
		if (cross) cat("Bounding box", n, "intersects p0 D65 bb\n")#
#
		inter <- doSegmentsIntersect(#
	        segment1 = c(p0x, p0y, Dx, Dy),#
	        segment2 = c(xy[n,1], xy[n,2], xy[n+1,1], xy[n+1,2]))#
	    if (inter) {#
	    	cat("p0 D65 intersects segment", n, "\n")#
	    	keep <- c(keep, n)#
	    	}#
		}#
 	verts <- rbind(CIExyz[keep,], CIExyz[max(keep)+1,], c(NA, NA, Dx, Dy, NA))#
 	return(verts)#
#
	}
selectCIExy <- function(L1 = NULL, L2 = NULL) {#
	getBoundingBox <- function(P0, P1) {#
	    llx <- min(P0[1], P1[1])#
	    lly <- min(P0[2], P1[2])#
	    urx <- max(P0[1], P1[1])#
	    ury <- max(P0[2], P1[2])#
	    bb <- c(llx, lly, urx, ury)#
	    }#
	doBoxesIntersect <- function(box1, box2) {#
	    ans <- FALSE#
	    chk1 <- box1[1] <= box2[3]#
	    chk2 <- box1[3] >= box2[1]#
	    chk3 <- box1[2] <= box2[4]#
	    chk4 <- box1[4] >= box2[2]#
	    if (chk1 && chk2 && chk3 && chk4) ans <- TRUE#
	    ans#
	    }#
	isPointOnLine <- function(segment, point) {#
		newseg <- c(0.0, 0.0, segment[3] - segment[1], segment[4] - segment[2])#
		newpt <- c(point[1] - segment[1], point[2] - segment[2])#
		ans <- newseg[3]*newpt[2] - newpt[1]*newseg[4]#
		return(isTRUE(all.equal(abs(ans), 0)))#
		}#
	isPointRightOfLine <- function(segment, point) {#
		newseg <- c(0.0, 0.0, segment[3] - segment[1], segment[4] - segment[2])#
		newpt <- c(point[1] - segment[1], point[2] - segment[2])#
		ans <- newseg[3]*newpt[2] - newpt[1]*newseg[4]#
		return(ans < 0)#
		}#
	lineSegmentTouchesOrCrossesLine <- function(segment1, segment2) {#
		ans <- 	(isPointOnLine(segment1, segment2[1:2]) ||#
				isPointOnLine(segment1, segment2[3:4]) ||#
				xor(isPointRightOfLine(segment1, segment2[1:2]),#
				isPointRightOfLine(segment1, segment2[3:4])))#
		return(ans)#
		}#
	doSegmentsIntersect <- function(segment1, segment2) {#
		box1 <- getBoundingBox(segment1[1:2], segment1[3:4])#
		box2 <- getBoundingBox(segment2[1:2], segment2[3:4])#
		return(doBoxesIntersect(box1, box2) &&#
			lineSegmentTouchesOrCrossesLine(segment1, segment2) &&#
			lineSegmentTouchesOrCrossesLine(segment2, segment1))#
		}#
	if (is.null(L1)) stop("You must give a wavelength")#
	data(CIExyz) #
	xy <- CIExyz[,c(2,3)] #
	xy <- rbind(xy, xy[1,]) #
	ans <- grep(L1, CIExyz$wavelength)#
	ans <-ans[1] #
	xy[ans,]#
	p0x <- xy[ans,1]#
	p0y <- xy[ans,2]#
	D65 <- getWhiteValues("D65") #
	Dx <- D65[1,1]#
	Dy <- D65[1,2]#
	m0 <- (Dy - p0y) / (Dx - p0x) #
	b0 <- (-m0 * p0x) + p0y #
	x1 <- p0x#
	y1 <- p0y#
	x2 <- Dx#
	y2 <- Dy#
	its <- nrow(xy)-1#
	for (n in 1:its) {#
		den <- (x1 - x2) * (xy[n,2] - xy[n+1,2]) - (y1 - y2) * (xy[n,1] - xy[n+1,1])#
		if (den == 0) {#
			next#
			}#
		num1 <- (x1 * y2 - y1 * x2) * (xy[n,1] - xy[n+1,1])#
		num2 <- (x1 - x2) * (xy[n,1] * xy[n+1,2] - xy[n,2] * xy[n+1,1])#
		num3 <- (x1 * y2 - y1 * x2) * (xy[n,2] - xy[n+1,2])#
		num4 <- (y1 - y2) * (xy[n,1] * xy[n+1,2] - xy[n,2] * xy[n+1,1]) #
		Px = (num1 - num2)/den#
		Py = (num3 - num4)/den#
		}#
	keep <- c()#
	for (n in 1:its) {#
	   	cross <- doBoxesIntersect(#
	        getBoundingBox(P0 = c(p0x, p0y), P1 = c(Dx, Dy)),#
	        getBoundingBox(P0 = c(xy[n,1], xy[n,2]), P1 = c(xy[n+1,1], xy[n+1,2])))#
		if (cross) cat("Bounding box", n, "intersects p0 D65 bb\n")#
#
		inter <- doSegmentsIntersect(#
	        segment1 = c(p0x, p0y, Dx, Dy),#
	        segment2 = c(xy[n,1], xy[n,2], xy[n+1,1], xy[n+1,2]))#
	    if (inter) {#
	    	cat("p0 D65 intersects segment", n, "\n")#
	    	keep <- c(keep, n)#
	    	}#
		}#
 	verts <- rbind(CIExyz[keep,], CIExyz[max(keep)+1,], c(NA, Dx, Dy, NA))#
 	verts <- verts[,2:3]#
 	return(verts)#
#
	}
selectCIExy <- function(L1 = NULL, L2 = NULL) {#
	getBoundingBox <- function(P0, P1) {#
	    llx <- min(P0[1], P1[1])#
	    lly <- min(P0[2], P1[2])#
	    urx <- max(P0[1], P1[1])#
	    ury <- max(P0[2], P1[2])#
	    bb <- c(llx, lly, urx, ury)#
	    }#
	doBoxesIntersect <- function(box1, box2) {#
	    ans <- FALSE#
	    chk1 <- box1[1] <= box2[3]#
	    chk2 <- box1[3] >= box2[1]#
	    chk3 <- box1[2] <= box2[4]#
	    chk4 <- box1[4] >= box2[2]#
	    if (chk1 && chk2 && chk3 && chk4) ans <- TRUE#
	    ans#
	    }#
	isPointOnLine <- function(segment, point) {#
		newseg <- c(0.0, 0.0, segment[3] - segment[1], segment[4] - segment[2])#
		newpt <- c(point[1] - segment[1], point[2] - segment[2])#
		ans <- newseg[3]*newpt[2] - newpt[1]*newseg[4]#
		return(isTRUE(all.equal(abs(ans), 0)))#
		}#
	isPointRightOfLine <- function(segment, point) {#
		newseg <- c(0.0, 0.0, segment[3] - segment[1], segment[4] - segment[2])#
		newpt <- c(point[1] - segment[1], point[2] - segment[2])#
		ans <- newseg[3]*newpt[2] - newpt[1]*newseg[4]#
		return(ans < 0)#
		}#
	lineSegmentTouchesOrCrossesLine <- function(segment1, segment2) {#
		ans <- 	(isPointOnLine(segment1, segment2[1:2]) ||#
				isPointOnLine(segment1, segment2[3:4]) ||#
				xor(isPointRightOfLine(segment1, segment2[1:2]),#
				isPointRightOfLine(segment1, segment2[3:4])))#
		return(ans)#
		}#
	doSegmentsIntersect <- function(segment1, segment2) {#
		box1 <- getBoundingBox(segment1[1:2], segment1[3:4])#
		box2 <- getBoundingBox(segment2[1:2], segment2[3:4])#
		return(doBoxesIntersect(box1, box2) &&#
			lineSegmentTouchesOrCrossesLine(segment1, segment2) &&#
			lineSegmentTouchesOrCrossesLine(segment2, segment1))#
		}#
	if (is.null(L1)) stop("You must give a wavelength")#
	data(CIExyz) #
	xy <- CIExyz[,c(2,3)] #
	xy <- rbind(xy, xy[1,]) #
	ans <- grep(L1, CIExyz$wavelength)#
	ans <-ans[1] #
	xy[ans,]#
	p0x <- xy[ans,1]#
	p0y <- xy[ans,2]#
	D65 <- getWhiteValues("D65") #
	Dx <- D65[1,1]#
	Dy <- D65[1,2]#
	m0 <- (Dy - p0y) / (Dx - p0x) #
	b0 <- (-m0 * p0x) + p0y #
	x1 <- p0x#
	y1 <- p0y#
	x2 <- Dx#
	y2 <- Dy#
	its <- nrow(xy)-1#
	for (n in 1:its) {#
		den <- (x1 - x2) * (xy[n,2] - xy[n+1,2]) - (y1 - y2) * (xy[n,1] - xy[n+1,1])#
		if (den == 0) {#
			next#
			}#
		num1 <- (x1 * y2 - y1 * x2) * (xy[n,1] - xy[n+1,1])#
		num2 <- (x1 - x2) * (xy[n,1] * xy[n+1,2] - xy[n,2] * xy[n+1,1])#
		num3 <- (x1 * y2 - y1 * x2) * (xy[n,2] - xy[n+1,2])#
		num4 <- (y1 - y2) * (xy[n,1] * xy[n+1,2] - xy[n,2] * xy[n+1,1]) #
		Px = (num1 - num2)/den#
		Py = (num3 - num4)/den#
		}#
	keep <- c()#
	for (n in 1:its) {#
	   	cross <- doBoxesIntersect(#
	        getBoundingBox(P0 = c(p0x, p0y), P1 = c(Dx, Dy)),#
	        getBoundingBox(P0 = c(xy[n,1], xy[n,2]), P1 = c(xy[n+1,1], xy[n+1,2])))#
		if (cross) cat("Bounding box", n, "intersects p0 D65 bb\n")#
#
		inter <- doSegmentsIntersect(#
	        segment1 = c(p0x, p0y, Dx, Dy),#
	        segment2 = c(xy[n,1], xy[n,2], xy[n+1,1], xy[n+1,2]))#
	    if (inter) {#
	    	cat("p0 D65 intersects segment", n, "\n")#
	    	keep <- c(keep, n)#
	    	}#
		}#
 	print(keep)#
 	verts <- rbind(CIExyz[keep,], CIExyz[max(keep)+1,], c(NA, Dx, Dy, NA))#
#
 	return(verts)#
#
	}
?plotCIEselection
selectCIExy <- function(L1 = NULL, L2 = NULL) {#
	getBoundingBox <- function(P0, P1) {#
	    llx <- min(P0[1], P1[1])#
	    lly <- min(P0[2], P1[2])#
	    urx <- max(P0[1], P1[1])#
	    ury <- max(P0[2], P1[2])#
	    bb <- c(llx, lly, urx, ury)#
	    }#
	doBoxesIntersect <- function(box1, box2) {#
	    ans <- FALSE#
	    chk1 <- box1[1] <= box2[3]#
	    chk2 <- box1[3] >= box2[1]#
	    chk3 <- box1[2] <= box2[4]#
	    chk4 <- box1[4] >= box2[2]#
	    if (chk1 && chk2 && chk3 && chk4) ans <- TRUE#
	    ans#
	    }#
	isPointOnLine <- function(segment, point) {#
		newseg <- c(0.0, 0.0, segment[3] - segment[1], segment[4] - segment[2])#
		newpt <- c(point[1] - segment[1], point[2] - segment[2])#
		ans <- newseg[3]*newpt[2] - newpt[1]*newseg[4]#
		return(isTRUE(all.equal(abs(ans), 0)))#
		}#
	isPointRightOfLine <- function(segment, point) {#
		newseg <- c(0.0, 0.0, segment[3] - segment[1], segment[4] - segment[2])#
		newpt <- c(point[1] - segment[1], point[2] - segment[2])#
		ans <- newseg[3]*newpt[2] - newpt[1]*newseg[4]#
		return(ans < 0)#
		}#
	lineSegmentTouchesOrCrossesLine <- function(segment1, segment2) {#
		ans <- 	(isPointOnLine(segment1, segment2[1:2]) ||#
				isPointOnLine(segment1, segment2[3:4]) ||#
				xor(isPointRightOfLine(segment1, segment2[1:2]),#
				isPointRightOfLine(segment1, segment2[3:4])))#
		return(ans)#
		}#
	doSegmentsIntersect <- function(segment1, segment2) {#
		box1 <- getBoundingBox(segment1[1:2], segment1[3:4])#
		box2 <- getBoundingBox(segment2[1:2], segment2[3:4])#
		return(doBoxesIntersect(box1, box2) &&#
			lineSegmentTouchesOrCrossesLine(segment1, segment2) &&#
			lineSegmentTouchesOrCrossesLine(segment2, segment1))#
		}#
	if (is.null(L1)) stop("You must give a wavelength")#
	data(CIExyz) #
	xy <- CIExyz[,c(2,3)] #
	xy <- rbind(xy, xy[1,]) #
	ans <- grep(L1, CIExyz$wavelength)#
	ans <-ans[1] #
	xy[ans,]#
	p0x <- xy[ans,1]#
	p0y <- xy[ans,2]#
	D65 <- getWhiteValues("D65") #
	Dx <- D65[1,1]#
	Dy <- D65[1,2]#
	m0 <- (Dy - p0y) / (Dx - p0x) #
	b0 <- (-m0 * p0x) + p0y #
	x1 <- p0x#
	y1 <- p0y#
	x2 <- Dx#
	y2 <- Dy#
	its <- nrow(xy)-1#
	for (n in 1:its) {#
		den <- (x1 - x2) * (xy[n,2] - xy[n+1,2]) - (y1 - y2) * (xy[n,1] - xy[n+1,1])#
		if (den == 0) {#
			next#
			}#
		num1 <- (x1 * y2 - y1 * x2) * (xy[n,1] - xy[n+1,1])#
		num2 <- (x1 - x2) * (xy[n,1] * xy[n+1,2] - xy[n,2] * xy[n+1,1])#
		num3 <- (x1 * y2 - y1 * x2) * (xy[n,2] - xy[n+1,2])#
		num4 <- (y1 - y2) * (xy[n,1] * xy[n+1,2] - xy[n,2] * xy[n+1,1]) #
		Px = (num1 - num2)/den#
		Py = (num3 - num4)/den#
		}#
	keep <- c()#
	for (n in 1:its) {#
	   	cross <- doBoxesIntersect(#
	        getBoundingBox(P0 = c(p0x, p0y), P1 = c(Dx, Dy)),#
	        getBoundingBox(P0 = c(xy[n,1], xy[n,2]), P1 = c(xy[n+1,1], xy[n+1,2])))#
		inter <- doSegmentsIntersect(#
	        segment1 = c(p0x, p0y, Dx, Dy),#
	        segment2 = c(xy[n,1], xy[n,2], xy[n+1,1], xy[n+1,2]))#
	    if (inter) {#
	    	keep <- c(keep, n)#
	    	}#
		}#
 	print(keep)#
 	verts <- rbind(CIExyz[keep,], CIExyz[max(keep)+1,], c(NA, Dx, Dy, NA))#
	plotCIEselection(verts[,2:3])#
 	return(verts)#
#
	}
tmp <- selectCIExy(L1 = 550); tmp
tmp <- selectCIExy(L1 = 700); tmp
selectCIExy <- function(L1 = NULL, L2 = NULL) {#
	getBoundingBox <- function(P0, P1) {#
	    llx <- min(P0[1], P1[1])#
	    lly <- min(P0[2], P1[2])#
	    urx <- max(P0[1], P1[1])#
	    ury <- max(P0[2], P1[2])#
	    bb <- c(llx, lly, urx, ury)#
	    }#
	doBoxesIntersect <- function(box1, box2) {#
	    ans <- FALSE#
	    chk1 <- box1[1] <= box2[3]#
	    chk2 <- box1[3] >= box2[1]#
	    chk3 <- box1[2] <= box2[4]#
	    chk4 <- box1[4] >= box2[2]#
	    if (chk1 && chk2 && chk3 && chk4) ans <- TRUE#
	    ans#
	    }#
	isPointOnLine <- function(segment, point) {#
		newseg <- c(0.0, 0.0, segment[3] - segment[1], segment[4] - segment[2])#
		newpt <- c(point[1] - segment[1], point[2] - segment[2])#
		ans <- newseg[3]*newpt[2] - newpt[1]*newseg[4]#
		return(isTRUE(all.equal(abs(ans), 0)))#
		}#
	isPointRightOfLine <- function(segment, point) {#
		newseg <- c(0.0, 0.0, segment[3] - segment[1], segment[4] - segment[2])#
		newpt <- c(point[1] - segment[1], point[2] - segment[2])#
		ans <- newseg[3]*newpt[2] - newpt[1]*newseg[4]#
		return(ans < 0)#
		}#
	lineSegmentTouchesOrCrossesLine <- function(segment1, segment2) {#
		ans <- 	(isPointOnLine(segment1, segment2[1:2]) ||#
				isPointOnLine(segment1, segment2[3:4]) ||#
				xor(isPointRightOfLine(segment1, segment2[1:2]),#
				isPointRightOfLine(segment1, segment2[3:4])))#
		return(ans)#
		}#
	doSegmentsIntersect <- function(segment1, segment2) {#
		box1 <- getBoundingBox(segment1[1:2], segment1[3:4])#
		box2 <- getBoundingBox(segment2[1:2], segment2[3:4])#
		return(doBoxesIntersect(box1, box2) &&#
			lineSegmentTouchesOrCrossesLine(segment1, segment2) &&#
			lineSegmentTouchesOrCrossesLine(segment2, segment1))#
		}#
	if (is.null(L1)) stop("You must give a wavelength for L1")#
	if (is.null(L2)) stop("You must give a wavelength for L2")#
#
	data(CIExyz) #
	xy <- CIExyz[,c(2,3)] #
	xy <- rbind(xy, xy[1,]) #
	ans1 <- grep(L1, CIExyz$wavelength)#
	ans1 <-ans1[1] #
	ans2 <- grep(L2, CIExyz$wavelength)#
	ans2 <-ans2[1] #
	xy[ans1,]#
	p0x <- xy[ans1,1]#
	p0y <- xy[ans1,2]#
	p1x <- xy[ans2,1]#
	p1y <- xy[ans2,2]#
	D65 <- getWhiteValues("D65") #
	Dx <- D65[1,1]#
	Dy <- D65[1,2]#
	m0 <- (Dy - p0y) / (Dx - p0x) #
	b0 <- (-m0 * p0x) + p0y #
	segs <- data.frame(x = c(p0x, p1x, Dx), y = c(p0y, p1y, Dy))#
	row.names(segs) <- c("p0", "p1", "D65")#
	print(segs)#
	x1 <- p0x#
	y1 <- p0y#
	x2 <- Dx#
	y2 <- Dy#
	its <- nrow(xy)-1#
	for (n in 1:its) {#
		den <- (x1 - x2) * (xy[n,2] - xy[n+1,2]) - (y1 - y2) * (xy[n,1] - xy[n+1,1])#
		if (den == 0) {#
			next#
			}#
		num1 <- (x1 * y2 - y1 * x2) * (xy[n,1] - xy[n+1,1])#
		num2 <- (x1 - x2) * (xy[n,1] * xy[n+1,2] - xy[n,2] * xy[n+1,1])#
		num3 <- (x1 * y2 - y1 * x2) * (xy[n,2] - xy[n+1,2])#
		num4 <- (y1 - y2) * (xy[n,1] * xy[n+1,2] - xy[n,2] * xy[n+1,1]) #
		Px = (num1 - num2)/den#
		Py = (num3 - num4)/den#
		}#
	keep <- c()#
	for (n in 1:its) {#
		inter <- doSegmentsIntersect(#
	        segment1 = c(p0x, p0y, Dx, Dy),#
	        segment2 = c(xy[n,1], xy[n,2], xy[n+1,1], xy[n+1,2]))#
	    if (inter) {#
	    	keep <- c(keep, n)#
	    	}#
		}#
 	verts <- rbind(CIExyz[keep,], CIExyz[max(keep)+1,], c(NA, Dx, Dy, NA))#
	plotCIEselection(verts[,2:3])#
 	return(verts)#
#
	}
tmp <- selectCIExy(L1 = 500); tmp
selectCIExy <- function(L1 = NULL, L2 = NULL) {#
	getBoundingBox <- function(P0, P1) {#
	    llx <- min(P0[1], P1[1])#
	    lly <- min(P0[2], P1[2])#
	    urx <- max(P0[1], P1[1])#
	    ury <- max(P0[2], P1[2])#
	    bb <- c(llx, lly, urx, ury)#
	    }#
	doBoxesIntersect <- function(box1, box2) {#
	    ans <- FALSE#
	    chk1 <- box1[1] <= box2[3]#
	    chk2 <- box1[3] >= box2[1]#
	    chk3 <- box1[2] <= box2[4]#
	    chk4 <- box1[4] >= box2[2]#
	    if (chk1 && chk2 && chk3 && chk4) ans <- TRUE#
	    ans#
	    }#
	isPointOnLine <- function(segment, point) {#
		newseg <- c(0.0, 0.0, segment[3] - segment[1], segment[4] - segment[2])#
		newpt <- c(point[1] - segment[1], point[2] - segment[2])#
		ans <- newseg[3]*newpt[2] - newpt[1]*newseg[4]#
		return(isTRUE(all.equal(abs(ans), 0)))#
		}#
	isPointRightOfLine <- function(segment, point) {#
		newseg <- c(0.0, 0.0, segment[3] - segment[1], segment[4] - segment[2])#
		newpt <- c(point[1] - segment[1], point[2] - segment[2])#
		ans <- newseg[3]*newpt[2] - newpt[1]*newseg[4]#
		return(ans < 0)#
		}#
	lineSegmentTouchesOrCrossesLine <- function(segment1, segment2) {#
		ans <- 	(isPointOnLine(segment1, segment2[1:2]) ||#
				isPointOnLine(segment1, segment2[3:4]) ||#
				xor(isPointRightOfLine(segment1, segment2[1:2]),#
				isPointRightOfLine(segment1, segment2[3:4])))#
		return(ans)#
		}#
	doSegmentsIntersect <- function(segment1, segment2) {#
		box1 <- getBoundingBox(segment1[1:2], segment1[3:4])#
		box2 <- getBoundingBox(segment2[1:2], segment2[3:4])#
		return(doBoxesIntersect(box1, box2) &&#
			lineSegmentTouchesOrCrossesLine(segment1, segment2) &&#
			lineSegmentTouchesOrCrossesLine(segment2, segment1))#
		}#
	if (is.null(L1)) stop("You must give a wavelength for L1")#
	if (is.null(L2)) stop("You must give a wavelength for L2")#
#
	data(CIExyz) #
	xy <- CIExyz[,c(2,3)] #
	xy <- rbind(xy, xy[1,]) #
	ans1 <- grep(L1, CIExyz$wavelength)#
	ans1 <-ans1[1] #
	ans2 <- grep(L2, CIExyz$wavelength)#
	ans2 <-ans2[1] #
#
	D65 <- getWhiteValues("D65")#
	segs <- data.frame(#
		x = c(xy[ans1,1], xy[ans2,1], D65[1,1]),#
		y = c(xy[ans1,2], xy[ans2,2], D65[1,2]))#
	row.names(segs) <- c("p0", "p1", "D65")#
	m0 <- (Dy - p0y) / (Dx - p0x) #
	b0 <- (-m0 * p0x) + p0y #
	keep <- c()#
#
	for (i in 1:2) { #
		its <- nrow(xy)-1#
		for (n in 1:its) { #
			inter <- doSegmentsIntersect(#
		        segment1 = c(segs[i,1], segs[i,2], segs[3,1], segs[3,2]),#
		        segment2 = c(xy[n,1], xy[n,2], xy[n+1,1], xy[n+1,2]))#
		    if (inter) {#
		    	keep <- c(keep, n)#
		    	}#
			}#
 	}#
 	verts <- rbind(CIExyz[keep,], CIExyz[max(keep)+1,], c(NA, segs[3,1], segs[3,2], NA))#
	plotCIEselection(verts[,2:3])#
 	return(verts)#
#
	}
selectCIExy <- function(L1 = NULL, L2 = NULL) {#
	getBoundingBox <- function(P0, P1) {#
	    llx <- min(P0[1], P1[1])#
	    lly <- min(P0[2], P1[2])#
	    urx <- max(P0[1], P1[1])#
	    ury <- max(P0[2], P1[2])#
	    bb <- c(llx, lly, urx, ury)#
	    }#
	doBoxesIntersect <- function(box1, box2) {#
	    ans <- FALSE#
	    chk1 <- box1[1] <= box2[3]#
	    chk2 <- box1[3] >= box2[1]#
	    chk3 <- box1[2] <= box2[4]#
	    chk4 <- box1[4] >= box2[2]#
	    if (chk1 && chk2 && chk3 && chk4) ans <- TRUE#
	    ans#
	    }#
	isPointOnLine <- function(segment, point) {#
		newseg <- c(0.0, 0.0, segment[3] - segment[1], segment[4] - segment[2])#
		newpt <- c(point[1] - segment[1], point[2] - segment[2])#
		ans <- newseg[3]*newpt[2] - newpt[1]*newseg[4]#
		return(isTRUE(all.equal(abs(ans), 0)))#
		}#
	isPointRightOfLine <- function(segment, point) {#
		newseg <- c(0.0, 0.0, segment[3] - segment[1], segment[4] - segment[2])#
		newpt <- c(point[1] - segment[1], point[2] - segment[2])#
		ans <- newseg[3]*newpt[2] - newpt[1]*newseg[4]#
		return(ans < 0)#
		}#
	lineSegmentTouchesOrCrossesLine <- function(segment1, segment2) {#
		ans <- 	(isPointOnLine(segment1, segment2[1:2]) ||#
				isPointOnLine(segment1, segment2[3:4]) ||#
				xor(isPointRightOfLine(segment1, segment2[1:2]),#
				isPointRightOfLine(segment1, segment2[3:4])))#
		return(ans)#
		}#
	doSegmentsIntersect <- function(segment1, segment2) {#
		box1 <- getBoundingBox(segment1[1:2], segment1[3:4])#
		box2 <- getBoundingBox(segment2[1:2], segment2[3:4])#
		return(doBoxesIntersect(box1, box2) &&#
			lineSegmentTouchesOrCrossesLine(segment1, segment2) &&#
			lineSegmentTouchesOrCrossesLine(segment2, segment1))#
		}#
	if (is.null(L1)) stop("You must give a wavelength for L1")#
	if (is.null(L2)) stop("You must give a wavelength for L2")#
#
	data(CIExyz) #
	xy <- CIExyz[,c(2,3)] #
	xy <- rbind(xy, xy[1,]) #
	ans1 <- grep(L1, CIExyz$wavelength)#
	ans1 <-ans1[1] #
	ans2 <- grep(L2, CIExyz$wavelength)#
	ans2 <-ans2[1] #
#
	D65 <- getWhiteValues("D65")#
	segs <- data.frame(#
		x = c(xy[ans1,1], xy[ans2,1], D65[1,1]),#
		y = c(xy[ans1,2], xy[ans2,2], D65[1,2]))#
	row.names(segs) <- c("p0", "p1", "D65")#
	keep <- c()#
#
	for (i in 1:2) { #
		its <- nrow(xy)-1#
		for (n in 1:its) { #
			inter <- doSegmentsIntersect(#
		        segment1 = c(segs[i,1], segs[i,2], segs[3,1], segs[3,2]),#
		        segment2 = c(xy[n,1], xy[n,2], xy[n+1,1], xy[n+1,2]))#
		    if (inter) {#
		    	keep <- c(keep, n)#
		    	}#
			}#
 	}#
 	verts <- rbind(CIExyz[keep,], CIExyz[max(keep)+1,], c(NA, segs[3,1], segs[3,2], NA))#
	plotCIEselection(verts[,2:3])#
 	return(verts)#
#
	}
tmp <- selectCIExy(L1 = 500, L2 = 510); tmp
?data
tmp <- selectCIExy(L1 = 450, L2 = 480); tmp
tmp <- selectCIExy(L1 = 550, L2 = 620); tmp
selectCIExy <- function(L1 = NULL, L2 = NULL) {#
	getBoundingBox <- function(P0, P1) {#
	    llx <- min(P0[1], P1[1])#
	    lly <- min(P0[2], P1[2])#
	    urx <- max(P0[1], P1[1])#
	    ury <- max(P0[2], P1[2])#
	    bb <- c(llx, lly, urx, ury)#
	    }#
	doBoxesIntersect <- function(box1, box2) {#
	    ans <- FALSE#
	    chk1 <- box1[1] <= box2[3]#
	    chk2 <- box1[3] >= box2[1]#
	    chk3 <- box1[2] <= box2[4]#
	    chk4 <- box1[4] >= box2[2]#
	    if (chk1 && chk2 && chk3 && chk4) ans <- TRUE#
	    ans#
	    }#
	isPointOnLine <- function(segment, point) {#
		newseg <- c(0.0, 0.0, segment[3] - segment[1], segment[4] - segment[2])#
		newpt <- c(point[1] - segment[1], point[2] - segment[2])#
		ans <- newseg[3]*newpt[2] - newpt[1]*newseg[4]#
		return(isTRUE(all.equal(abs(ans), 0)))#
		}#
	isPointRightOfLine <- function(segment, point) {#
		newseg <- c(0.0, 0.0, segment[3] - segment[1], segment[4] - segment[2])#
		newpt <- c(point[1] - segment[1], point[2] - segment[2])#
		ans <- newseg[3]*newpt[2] - newpt[1]*newseg[4]#
		return(ans < 0)#
		}#
	lineSegmentTouchesOrCrossesLine <- function(segment1, segment2) {#
		ans <- 	(isPointOnLine(segment1, segment2[1:2]) ||#
				isPointOnLine(segment1, segment2[3:4]) ||#
				xor(isPointRightOfLine(segment1, segment2[1:2]),#
				isPointRightOfLine(segment1, segment2[3:4])))#
		return(ans)#
		}#
	doSegmentsIntersect <- function(segment1, segment2) {#
		box1 <- getBoundingBox(segment1[1:2], segment1[3:4])#
		box2 <- getBoundingBox(segment2[1:2], segment2[3:4])#
		return(doBoxesIntersect(box1, box2) &&#
			lineSegmentTouchesOrCrossesLine(segment1, segment2) &&#
			lineSegmentTouchesOrCrossesLine(segment2, segment1))#
		}#
	if (is.null(L1)) stop("You must give a wavelength for L1")#
	if (is.null(L2)) stop("You must give a wavelength for L2")#
#
	data(CIExyz) #
	xy <- CIExyz[,c(2,3)] #
	xy <- rbind(xy, xy[1,]) #
	ans1 <- grep(L1, CIExyz$wavelength)#
	ans1 <-ans1[1] #
	ans2 <- grep(L2, CIExyz$wavelength)#
	ans2 <-ans2[1] #
#
	D65 <- getWhiteValues("D65")#
	segs <- data.frame(#
		x = c(xy[ans1,1], xy[ans2,1], D65[1,1]),#
		y = c(xy[ans1,2], xy[ans2,2], D65[1,2]))#
	row.names(segs) <- c("p0", "p1", "D65")#
	keep <- c()#
#
	for (i in 1:2) { #
		its <- nrow(xy)-1#
		for (n in 1:its) { #
			inter <- doSegmentsIntersect(#
		        segment1 = c(segs[i,1], segs[i,2], segs[3,1], segs[3,2]),#
		        segment2 = c(xy[n,1], xy[n,2], xy[n+1,1], xy[n+1,2]))#
		    if (inter) {#
		    	keep <- c(keep, n)#
		    	}#
			}#
 	}#
 	mink <- min(keep)#
 	maxk <- max(keep)#
 	verts <- rbind(CIExyz[mink:maxk,], CIExyz[maxk+1,], c(NA, segs[3,1], segs[3,2], NA))#
	plotCIEselection(verts[,2:3])#
 	return(verts)#
#
	}
tmp <- selectCIExy(L1 = 525, L2 = 550); tmp
tmp <- selectCIExy(L1 = 500, L2 = 550); tmp
tmp <- selectCIExy(L1 = 480, L2 = 575)
selectCIExy <- function(L1 = NULL, L2 = NULL) {#
	getBoundingBox <- function(P0, P1) {#
	    llx <- min(P0[1], P1[1])#
	    lly <- min(P0[2], P1[2])#
	    urx <- max(P0[1], P1[1])#
	    ury <- max(P0[2], P1[2])#
	    bb <- c(llx, lly, urx, ury)#
	    }#
	doBoxesIntersect <- function(box1, box2) {#
	    ans <- FALSE#
	    chk1 <- box1[1] <= box2[3]#
	    chk2 <- box1[3] >= box2[1]#
	    chk3 <- box1[2] <= box2[4]#
	    chk4 <- box1[4] >= box2[2]#
	    if (chk1 && chk2 && chk3 && chk4) ans <- TRUE#
	    ans#
	    }#
	isPointOnLine <- function(segment, point) {#
		newseg <- c(0.0, 0.0, segment[3] - segment[1], segment[4] - segment[2])#
		newpt <- c(point[1] - segment[1], point[2] - segment[2])#
		ans <- newseg[3]*newpt[2] - newpt[1]*newseg[4]#
		return(isTRUE(all.equal(abs(ans), 0)))#
		}#
	isPointRightOfLine <- function(segment, point) {#
		newseg <- c(0.0, 0.0, segment[3] - segment[1], segment[4] - segment[2])#
		newpt <- c(point[1] - segment[1], point[2] - segment[2])#
		ans <- newseg[3]*newpt[2] - newpt[1]*newseg[4]#
		return(ans < 0)#
		}#
	lineSegmentTouchesOrCrossesLine <- function(segment1, segment2) {#
		ans <- 	(isPointOnLine(segment1, segment2[1:2]) ||#
				isPointOnLine(segment1, segment2[3:4]) ||#
				xor(isPointRightOfLine(segment1, segment2[1:2]),#
				isPointRightOfLine(segment1, segment2[3:4])))#
		return(ans)#
		}#
	doSegmentsIntersect <- function(segment1, segment2) {#
		box1 <- getBoundingBox(segment1[1:2], segment1[3:4])#
		box2 <- getBoundingBox(segment2[1:2], segment2[3:4])#
		return(doBoxesIntersect(box1, box2) &&#
			lineSegmentTouchesOrCrossesLine(segment1, segment2) &&#
			lineSegmentTouchesOrCrossesLine(segment2, segment1))#
		}#
	if (is.null(L1)) stop("You must give a wavelength for L1")#
	if (is.null(L2)) stop("You must give a wavelength for L2")#
	if (L1 > L2) stop("L1 must be less than L2")#
	data(CIExyz) #
	xy <- CIExyz[,c(2,3)] #
	xy <- rbind(xy, xy[1,]) #
	ans1 <- grep(L1, CIExyz$wavelength)#
	ans1 <-ans1[1] #
	ans2 <- grep(L2, CIExyz$wavelength)#
	ans2 <-ans2[1] #
#
	D65 <- getWhiteValues("D65")#
	segs <- data.frame(#
		x = c(xy[ans1,1], xy[ans2,1], D65[1,1]),#
		y = c(xy[ans1,2], xy[ans2,2], D65[1,2]))#
	row.names(segs) <- c("p0", "p1", "D65")#
	keep <- c()#
#
	for (i in 1:2) { #
		its <- nrow(xy)-1#
		for (n in 1:its) { #
			inter <- doSegmentsIntersect(#
		        segment1 = c(segs[i,1], segs[i,2], segs[3,1], segs[3,2]),#
		        segment2 = c(xy[n,1], xy[n,2], xy[n+1,1], xy[n+1,2]))#
		    if (inter) keep <- c(keep, n)#
			}#
 	}#
#
 	mink <- min(keep)#
 	maxk <- max(keep)#
 	verts <- rbind(CIExyz[mink:maxk,], CIExyz[maxk+1,], c(NA, segs[3,1], segs[3,2], NA))#
	plotCIEselection(verts[,2:3])#
 	return(verts)#
#
	}
tmp <- selectCIExy(L1 = 420, L2 = 460)
